Chapter 5: Programming Algorithms & Software Testing
<html>
   <body>
<ol>Phases of computer program development:
        <h3>Phase 1: Understandnthe problem</h3>
        <h3>Phase 2: Design an algorithm to solve the problem</h3>
        <h3>Phase 3: Write the program code in appropriate language based on the algorithm</h3>
        <h3>Phase 4: Enter the program and save</h3>
        <h3>Phase 5: Execute the program</h3>
        <h3>Phase 6: Test the program, find errors and debug, then retest</h3>
        <h3>Phase 7: Document and evaluate the program</h3>
</ol>
<h4>Programming structures:</h4>
         <ol>structure: Top-down execution</ol>
        <ol>Decision structures: if/then/else</ol>
        <h4>Iteractive (Looping):</h4>
                <p>while loop: continue looping as long as something is true
                repeat/until loop: continue looping until something is true
                for loop: loop a given number of times</p>
        <h4>Recursive structures:</h4>
                Repeat a set of instructions as a subtask of itself
                <h5>Repetition continues until:</h5>
                        degenerative case, which is a termination condition, is
                        (degenerative case is also called a "base case")
<h4>Two classic programming/database problems</h4>
        Sorting: Descending order/Ascending order
                Sorting numbers
                Sorting strings (in accordence with ASCII values)
        Searching: find specific data that meet a certain criteria
                In database:
                        Filters: temporary search
                        Queries: search criteria are saved so they don't have to be recreated
        Two popular search techniques:
                Sequential search: search from top to bottom or bottom to top, one item at a time
                Binary search:
                        only works if data is SORTED first
                        start in the middle, then go to half to that, etc.
<h4>Two classic program goals:</h4>
        <ol>Efficieny: Program takes minimal time and/or resources
        <p>Correctness: Program runs in expected way and works for all expected conditions</p></ol>


<h4>Software testing and verification</h4>
        Kinds of tests:
(find the definitions for these here:<a href>https://www.ibm.com/topic/software-testing)</a>
                <ol><Acceptence testing: Verifying whether the whole system works as intended.
                <h5>Intergration testing:</h5> Ensuring that software components or functions operate together.
                <h5>Unit testing: Validating</h5> that each software unit performs as expected. A unit is the smallest testable component of an application.
                <h5>Functional testing:</h5> Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.
                <h5>Performance testing:</h5> Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.
                <h5>Regression testing:</h5> Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.
                <h5>Stress testing:</h5> Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.
                <h5>Usability testing:</h5> Validating how well a customer can use a system or web application to complete a task.
                </ol>
        <h4>Software testing is done to detect:</h4>
        <ul>
                <li>Architectural flaws</li>
                <li>Poor design decisions</li>
                <li>Invalid or incorrect functionality</li>
                <li>Security vulnerabilities</li>
                <li>Scalability issues</li>
        </ul>
        <h4>Testing best practices:</h4>
    (explain these--see the IBM web site for the information)
        <ul>
                <li>Continous testing- Project teams test builds as they become available using automation intergrated within development.</li>
                <li>Configuration management- Organizations centrally maintain test assests and track what software builds to test</li>
                <li>Servic virtualization- Testing enviornments may not be available, this allows you to reduce dependencies and test sooner, they can reuse and change configurations to test without modifiying</li>
                <li>Defect or "bug tracking"- Automated tools help track defects, measure the scope and impact, and uncover related issues.</li>
                <li>Metrics and reporting- Advanced tools intergrate metrics and present results to the dashboard where teams can share goals, stats, and results</li>
        From: IBM What is software testing?(make this a link to: https://www.ibm.com/topic/software-testing)
        </ul>
   </body>   
</html>